import sys
import os
import os.path
import time
import sh
import fnmatch
import logging
import subprocess
import re
import unittest
import shutil
import glob
import fnmatch
from collections import namedtuple
from pynt import task

sys.path.insert(0,".")

def execute(prefix,cmd):
    stmt=" ".join(cmd)
    print prefix,stmt
    os.system(stmt)


@task()
def utest():
    ''' Runs all unit tests with a progress indicator '''

    from test import run

    # setup test options
    class Opts(object):
        def __init__(self):
            self.useXMLRunner=False
            self.verbosity=1

    run(Opts())


@task()
def coverage():
    ''' Runs the unit tests with coverage and produces the report in htmlcov
    '''
    from coverage import coverage

    # run unit tests with code coverage
    cov=coverage()
    cov.start()

    utest()

    cov.stop()
    cov.html_report()


@task()
def pdoc():
    ''' Generates the python documentation in htmldoc
    '''
    import shutil
    pdoc=os.path.join(os.path.dirname(sys.executable),'pdoc')
    try:
        shutil.rmtree('htmldoc')
    except OSError:
        pass

    cmd=(
        "PYTHONPATH=.",
        pdoc,
        "--overwrite",
        "--html-dir", "htmldoc",
        "--html-no-source",
        "--html",
        "--all-submodules"
    )
    modules=(
        "albackup",
    )
    for m in modules:
        execute("Generating documentation:", cmd+(m,))


class ImportCheckFailed(Exception):
    pass

@task()
def importchecker():
    ''' Checks the python sources for unneccessary imports '''
    from pyflakes.scripts.pyflakes import main

    try:
        main(args=['albackup'])
    except SystemExit,ex:
        if ex.message:
            raise
        else:
            print "pyflakes found not issues"


@task()
def fullBuild():
    ''' Performs a full build '''
    importchecker()
    coverage()
    pdoc()

@task()
def clean():
    ''' Remove artifacts generated by the build '''
    rmList=(
        "htmlcov/*",
        "htmldoc/*",
        "**/*.pyc"
    )
    for rm in rmList:
        if rm[0:3]=='**/':
            for root,dirnames,fnames in os.walk('.'):
                for f in fnmatch.filter(fnames, rm[3:]):
                    f=os.path.join(root,f)
                    print "Removing {}".format(f)
                    os.remove(f)
        else:
            for f in glob.iglob(rm):
                print "Removing {}".format(f)
                if os.path.isdir(f) and not os.path.islink(f):
                    shutil.rmtree(f)    
                else:
                    os.remove(f)    



__DEFAULT__=coverage

if __name__ == '__main__':
    from pkg_resources import load_entry_point
    sys.exit(
        load_entry_point('pynt==0.8.1', 'console_scripts', 'pynt')()
    )
